#!/usr/bin/env ruby

require 'digest/sha1'

def get_message
  msg = `git config vein.default`.chomp
  unless msg =~ /\A[a-f0-9]{2,10}\z/
    abort "ERROR: vein.default not set, or not lowercase hex\nhint: git config --global --add vein.default <hex>"
  end
  msg
end

def parse_commit
  original = `git cat-file -p HEAD`
  parts = original.split(/(^author.*> |committer.*> )(\d+)(.*$)/, 3)
  [ parts[0..1].join,
    parts[2   ].to_i,
    parts[3..5].join,
    parts[6   ].to_i,
    parts[7..-1].join ]
end

def format_progress(ad, cd, hashes, rewrite="\r")
  print "∆author: %5d, ∆committor: %5d, khash: %d#{rewrite}" % [ad,cd,hashes/1000]
end

def search(message, parsed_commit)
  puts "searching for: #{message}"
  @head, @t_author, @middle, @t_committer, @rest = parsed_commit
  counter = 0

  (0..3600).each do |a|
  [a*1,a*-1].uniq.each do |ad|
    auth_t = @t_author+ad
  (0..3600).each do |c|
  [c*1,c*-1].uniq.each do |cd|
    comm_t = @t_committer+cd
    content = [@head, auth_t, @middle, comm_t, @rest].join
    store = "commit #{content.length}\0" + content
    sha1 = Digest::SHA1.hexdigest(store)

    if sha1.start_with?(message)
      format_progress(ad,cd,counter,"\n")
      return [content,sha1]
    end

    counter += 1
    format_progress(ad,cd,counter) if (counter%100000).zero?
  end
  end
  end
  end
end

content, sha1 = search(get_message, parse_commit)

exit if ARGV.include? "--dry-run"

File.open("/tmp/commit", 'w') {|f| f.write(content) }
sha2=`git hash-object -t commit /tmp/commit`.strip

if sha1==sha2
  system("git reset --soft HEAD^")
  system("git hash-object -t commit -w /tmp/commit")
  system("git reset --soft #{sha1}")
else
  puts "failed, git doesn't agree:"
  puts sha1
  puts sha2
  exit 1
end
